sudo: required
language: java
env:
  global:
    - zipkinHost=localhost
    - zipkinPort=9411
    - jwtid=myMpJwt
    - IMAGE_NAME=orders-mp
    - TAG=travis
    - RELEASE_NAME=orders
jdk:
  - openjdk8
stages:
  - local build and test
  - kubernetes build, deploy, and test
jobs:
  include:
    # - stage: local build and test
    #   services:
    #   - mysql
    #   env:
    #     - jdbcURL=jdbc:mysql://localhost:9039/ordersdb?useSSL=false
    #     - dbuser=root
    #     - dbpassword=password
    #     - auth_health=https://localhost:9443/health
    #     - inventory_url=http://localhost:9081/inventory/rest/inventory/stock
    #     - inventory_health=http://localhost:9081/health
    #     - rabbit=localhost
    #     - jwksUri=https://localhost:9443/oidc/endpoint/OP/jwk
    #     - jwksIssuer=https://localhost:9443/oidc/endpoint/OP
    #     - administratorRealm=https://localhost:9443/oidc/endpoint/OP
    #     - zipkinHost=localhost
    #     - zipkinPort=9411
    #   before_script:
    #   - export GATEWAY=$(docker network inspect bridge | grep "Gateway" | awk '/"/{print $2}' | sed -e 's/^"//' -e 's/"$//')
    #   # Start RabbitMQ
    #   - docker pull rabbitmq
    #   - docker run -p 5672:5672 -d rabbitmq
    #   # Generate the Keystore
    #   - bash scripts/keygen.sh
    #   - sudo cp -r keystorevol /etc/
    #   # Run Auth, put keystore in, and start it
    #   - docker pull ibmcase/auth-mp:v3.0.0
    #   - docker create --name auth -p 9443:9443 -p 9080:9080 ibmcase/auth-mp:v3.0.0
    #   - docker cp keystorevol auth:/etc/
    #   - docker start auth
    #   # Pull and run inventorydb
    #   - docker pull ibmcase/bc-inventorydb:v2.0.0
    #   - docker run -p 9041:3306 -d --name inventorydb -e MYSQL_ROOT_PASSWORD=password ibmcase/bc-inventorydb:v2.0.0
    #   # Run Inventory and start it w/ vars
    #   - docker pull ibmcase/inventory-mp:v2.0.0
    #   - docker create --name inventory -p 9444:9443 -p 9081:9080 -e zipkinHost=localhost -e zipkinPort=9411 -e jdbcURL=jdbc:mysql://${GATEWAY}:9041/inventorydb?useSSL=false -e dbuser=root -e dbpassword=password -e rabbit=${GATEWAY} ibmcase/inventory-mp:v2.0.0
    #   - docker start inventory
    #   # Build and run ordersdb
    #   - cd mysql
    #   - docker build -t ordersdb .
    #   - docker run -p 9039:3306 -d --name ordersdb -e MYSQL_ROOT_PASSWORD=password ordersdb
    #   - cd -
    #   script:
    #   # Maven Build
    #   - mvn clean install
    #   # Start Application
    #   - mvn liberty:start-server -DtestServerHttpPort=9083 -DtestServerHttpsPort=9446
    #   # Wait for the Orders container to start accepting connections
    #   - sleep 25
    #   # Run Orders API Test
    #   - bash scripts/api_tests.sh
    - stage: kubernetes build, deploy, and test
      services:
      - docker
      env:
      - CHANGE_MINIKUBE_NONE_USER=true
      install:
        - true
      before_script:
      # Install nsenter, which is needed for minikube to work
      - bash scripts/install_minikube_and_helm.sh
      # Define a local Keystore
      - bash scripts/keygen.sh
      - sudo cp -r keystorevol /etc/
      # Run Kubernetes Job and run Auth (May not need keystore chart)
      - helm install --name keystore services-bc-mp/keystore
      - helm install --name auth services-bc-mp/auth
      - MINIKUBE_IP=$(minikube ip)
      - AUTH_NODE_PORT=$(kubectl get service auth-auth -o=jsonpath='{.spec.ports[1].nodePort}')
      # Run OrdersDB
      # - docker pull ibmcase/bc-inventorydb:v2.0.0
      # - helm install --name my-release --set mysqlRootPassword=password,mysqlUser=dbuser,mysqlPassword=password,mysqlDatabase=inventorydb,image=ibmcase/bc-inventorydb,tag=v2.0.0 stable/mysql
      - helm install --name my-release --set mysqlRootPassword=password,mysqlUser=dbuser,mysqlPassword=password,mysqlDatabase=ordersdb stable/mysql
      # Run inventory
      - helm install --set travis=true --name inventory services-bc-mp/inventory
      script:
      # Maven Build
      - mvn clean install
      # Build Docker image
      - docker build -t "${IMAGE_NAME}:${TAG}" .
      # Install Orders
      # - helm install --set travis=true --set service.minikubeIp=$MINIKUBE_IP --set service.authKubePort=$AUTH_NODE_PORT --set image.repository=${IMAGE_NAME} --set image.tag=${TAG} --name ${RELEASE_NAME} ./chart/orders/
      - helm install --set travis=true --set service.minikubeIp=$MINIKUBE_IP,service.authKubePort=$AUTH_NODE_PORT,image.repository=${IMAGE_NAME},image.tag=${TAG} --name ${RELEASE_NAME} ./chart/orders/
      - ORDERS_POD=$(kubectl get pods | grep -v "orders-orders-job" | grep orders-orders | awk '{print $1}')
      - kubectl describe pod $ORDERS_POD
      - kubectl logs $ORDERS_POD
      # Wait for Orders to be ready
      - kubectl get deployments ${RELEASE_NAME}-orders -o yaml
      - READY=$(kubectl get deployments ${RELEASE_NAME}-orders -o yaml | grep "readyReplicas" | awk '{print $2}')
      - echo $READY
      - until [ -n "$READY" ] && [ ${READY} -ge 1 ]; do READY=$(kubectl get deployments ${RELEASE_NAME}-orders -o yaml | grep "readyReplicas" | awk '{print $2}'); kubectl get deployments -o wide; echo "Waiting for orders to be ready"; sleep 10; done
      # Wait for orders deployment to start accepting connections
      - sleep 35
      # Run auth API Test
      - ORDERS_NODE_PORT=$(kubectl get service orders-orders -o=jsonpath='{.spec.ports[1].nodePort}')
      - INV_NODE_PORT=$(kubectl get service inventory-inventory -o=jsonpath='{.spec.ports[0].nodePort}')
      - kubectl get services
      - bash scripts/api_tests.sh $MINIKUBE_IP $ORDERS_NODE_PORT $MINIKUBE_IP $AUTH_NODE_PORT $MINIKUBE_IP $INV_NODE_PORT